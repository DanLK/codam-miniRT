# **************************************************************************** #
#                                                                              #
#                                                          ::::::::            #
#    math.txt                                            :+:    :+:            #
#                                                       +:+                    #
#    By: hogu <hogu@student.codam.nl>                  +#+                     #
#                                                     +#+                      #
#    Created: 2025/08/14 10:15:46 by hogu           #+#    #+#                 #
#    Updated: 2025/08/14 10:15:47 by hogu           ########   odam.nl         #
#                                                                              #
# **************************************************************************** #

//camera ray
Known:
1. horizontal FOV = fov
2. image_height = 600, image_width = 800, viewport_ratio = 4/3
3. camera_position = (a, b, c)
4. camera_direction = (x, y, z)
4. viewport_distance = 1
5. t_vec world_up = (0, 1, 0)

Then:
1. fov_radian = fov * (M_PI / 180.0)
2. viewport_width = tan(fov_radian / 2.0) * viewport_distance * 2.0
3. viewport_height = viewport_width * viewport_ratio
4. viewport_center:
	center.x = a + x * 1.0
	center.y = b + y * 1.0
	center.z = c + z * 1.0
5. local direction on viewport:
	right = normalize(cross(world_up, camera_direction))
	up = normalize(cross(right, camera_direction))
6. upper left point on viewport:
	ulp = center + up * viewport_height / 2 - right * viewport_width / 2
7. pixel size
	pixel_width = viewport_width / image_width
	pixel_height = viewport_height / image_height
8. every point on viewport: (i, j)
	for i (0, 799), j (0, 599)
	t_vec pixel_pos = ulp + right * (i + 0.5) * pixel_width - up * (j + 0.5) * pixel_height
9. ray_vector = normalize(pixel_pos - camera_position)


//hitting cylinder
It is difficult to abstract a cylinder into one single intersection model.
A ray can hit the cylinder in one of three parts:
1. curved side surface
2. top cap (pointed to by axis)
3. bottom cap

For curved surface:
	O = ray.origin
	D = ray.dir
	C = cy.center
	V = cy.dir

1. hit_point = ray.origin + ray.dir * t = O + tD
2. create a vector m from hit_point to cylinder_center
	m = C - (O + tD)
3. get vector n from hit_point to axis, by subtracting m's projection on axis from m
	n = m - dot(m, V) * V

Summing up:
	n = (O - C + tD) - dot(O - C + tD, V) * V

	now let:
	w = O - C
	a = D - dot(D, V) * V
	b = w - dot(w, V) * V

	we get n = b + ta

4. length of n should be radius
	solve: (b + ta) ^ 2 = r ^ 2, the proces is similar to hit_sphere

5. check if hit_point is in between 2 caps
	-h / 2 <= dot(P - C, V) <= h / 2

For each cap:
1. determine a. t_coord cap_center, b. t_vec normal
2. check for parallel ray:
	- similar to hit_plane, get dot product of ray.dir and normal
	- if close to 0, then ray is parallel to cap, no intersection for sure
3. solve for the intersection point (if any)
	- sub_vec(hit_point, cap_center) should be perpendicular to normal
	- hit_point = ray.origin + ray.dir * t
	Details in calculation:
		O = ray.origin
		D = ray.dir
		C = cap_center
		N = normal

		dot(((O + tD) - C), N) = 0			=>
		dot((O - C + tD), N) = 0			=>
		dot(O - C, N) + dot(tD, N) = 0		=>
		dot(O - C, N) + t * dot(D, N) = 0	=>
		t = -dot(O - C, N) / dot(D, N)		=>
		t = dot(C - O, N) / denom
4. check whether hit_point lies inside the cap disk
	distance(hit_plane, cap_center) <= radius

//check_shadow
Checks if a hit_point is in shadow (i.e., blocked from the point light)

logic:
imagine a shadow ray between hit_point and light_point,
and apply hit_object again to all objects one by one, to check if convergence

known:
1. t_coord hit_point
2. t_object *obj
3. t_coord light_point

steps:
1. get the shadow ray from hit_point to light_point
	t_vec shadow_dir = sub_vec(lihgt_point, hit_point);
	t_ray shadow = set_ray(hit_point, shadow_dir);
2. hit_object(shadow, obj, &dist)
3. also check if dist > EPSILON and dist < len_vec of shadow ray
4. if true -> is in_shadow; otherwise -> not in_shadow


//calculate color

logic:
each pixel belongs to one of the three groups:
1. background: gradient
2. object in shadow: object_ambient_color
3. object in light: object_ambient_color + object_diffuse_color


// calculation for object_ambient_color:
	result_color = object_color × (ambient_color / 255.0) × ambient_ratio


//calculation for object_diffuse_color:
	result_color = object_color × light_color × diffuse_intensity × light_brightness;

	in which, diffuse_intensity = max(0.0, dot(normal, light_dir));
		The dot product describes how "directly" the surface is facing the light source.
		It gives the cosine of the angle between:
			a. surface normal vector
			b. the direction to the light source
		- the closer the value is to 1, the more directly the surface is lit
		- when close to 0, the surface is nearly parallel to the light direction
		- when negative, the surface is back-facing the point light, aka shadowed by itself,
		we take 0.0 for intensity to avoid nagetive lighting.


// Finding normal vector for hit_points on cylinder:
1. determine where is the hit_point: 1) bottom flat surface 2) top flat surface 3) curved surface
	(note: axis points towards the top cap)
	project the vector [from cylinder_center to hit_point] onto the cylinder's axis
	in which,
		t_vec v = hit_point - cylinder.center
		proj = dot(v, cylinder.dir)
	now we can determine hit_point position based on projection:
		- if proj = height / 2, the hit_point is on the top cap;
		- if proj = -height / 2 -> bottom cap;
		- if proj is within (-height / 2 , +height / 2), the hit_point is on the curved surface
2. determine the normal vector
	for hit_point on the top cap: same as axis vector
	for bottom cap: opposite to axis vector
	for curved surface: normalized(v - proj * axis)


//bonus: checkerboard color
To add checkekboard effect with minimal change to the existing code,
get_chkb_color() will return either object's original color (as defined in .rt scene),
or white, based on the hit point's position.

In .rt file, each object must explicitly specify whether the checkerboard pattern should be applied.
This is indicated by a string “True” or “False” immediately following the object's RGB color definition.

1. project hit_p to object local coordinate system
	a. create local coordinate
		For sphere, there's no need for a local coordinate system.
			- because it is naturally symmetrical, just use world coordinate system.

		For plane, local coordinate is a local 2D plane  => set_local_basis()
			z_axis = normal vector at the hit point (use get_normal())
			x_axis = normalized(cross(z_axis, world_up))
			y_axis = cross(z_axis, x_axis)

		For cylinder, take its cap as a plane.  => set_local_basis()

2. determine color
	a. For sphere, consider longtitude and latitude: => cal_sp_chkb()

		Step 1: compute the "normal vector", from sphere center to hit_point.

		Step 2: compute longtitude
		longtitude describes how far the direction has rotated around the y-axis,
		starting from x-positive direction.

		in code:
			longt = atan2(dir.z, dir.x)			//[-π, π]
			u = (longt + π) / (2 * π)			//map to [0,1]
		
		Step3: compute latitude
		latitude describes how far the direction is from the y-axis.

		in code:
			latit = acos(dir.y)					//[0, π]
			v = latit / π						//map to [0,1]

		Step 4: determine which color to return => coord_to_color()
		For easier calculation, we set the checkerboard pattern with 10 columns and 10 rows.

		int iu = (int)(u * 10)
		int iv = (int)(v * 10)
		if ((iu + iv) % 2 == 0)
			return base_color;
		else
			return white_color;
		
	b. For plane, find the hit point's position in the local coordinate system => cal_pl_chkb()

		Step 1: compute the vector from plane center to the hit point
		Step 2: project this vector to local x-axis and local y-axis respectively,
			and find the hit point's coordinates in the local basis.
		Step 3: Use floor() to divide all possible hit points into 2 groups, by summing up
			its local.x and local.y values, and see if it is even or not.

	c. For cylinder
		Step 1: determine hit point's location. use find_point_on_cylinder()
		Step 2: for hit_points on the curved surface => cal_cy_chkb_curved_surface()
