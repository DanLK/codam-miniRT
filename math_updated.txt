# **************************************************************************** #
#                                                                              #
#                                                          ::::::::            #
#    math.txt                                            :+:    :+:            #
#                                                       +:+                    #
#    By: hogu <hogu@student.codam.nl>                  +#+                     #
#                                                     +#+                      #
#    Created: 2025/08/14 10:15:46 by hogu           #+#    #+#                 #
#    Updated: 2025/08/14 10:15:47 by hogu           ########   odam.nl         #
#                                                                              #
# **************************************************************************** #

//camera ray
Known:
1. horizontal FOV = fov
2. image_height = 600, image_width = 800, viewport_ratio = 4/3
3. camera_position = (a, b, c)
4. camera_direction = (x, y, z)
4. viewport_distance = 1
5. t_vec world_up = (0, 1, 0)

Then:
1. fov_radian = fov * (M_PI / 180.0)
2. viewport_width = tan(fov_radian / 2.0) * viewport_distance * 2.0
3. viewport_height = viewport_width * viewport_ratio
4. viewport_center:
	center.x = a + x * 1.0
	center.y = b + y * 1.0
	center.z = c + z * 1.0
5. local direction on viewport:
	right = normalize(cross(world_up, camera_direction))
	up = normalize(cross(right, camera_direction))
6. upper left point on viewport:
	ulp = center + up * viewport_height / 2 - right * viewport_width / 2
7. pixel size
	pixel_width = viewport_width / image_width
	pixel_height = viewport_height / image_height
8. every point on viewport: (i, j)
	for i (0, 799), j (0, 599)
	t_vec pixel_pos = ulp + right * (i + 0.5) * pixel_width - up * (j + 0.5) * pixel_height
9. ray_vector = normalize(pixel_pos - camera_position)


//check_shadow
Checks if a hit_point is in shadow (i.e., blocked from the point light)

logic:
imagine a shadow ray between hit_point and light_point,
and apply hit_object again to all objects one by one, to check if convergence

known:
1. t_coord hit_point
2. t_object *obj
3. t_coord light_point

steps:
1. get the shadow ray from hit_point to light_point
	t_vec shadow_dir = sub_vec(lihgt_point, hit_point);
	t_ray shadow = set_ray(hit_point, shadow_dir);
2. hit_object(shadow, obj, &dist)
3. also check if dist > EPSILON and dist < len_vec of shadow ray
4. if true -> is in_shadow; otherwise -> not in_shadow


//calculate color

logic:
each pixel belongs to one of the three groups:
1. background: gradient
2. object in shadow: object_ambient_color
3. object in light: object_ambient_color + object_diffuse_color


// calculation for object_ambient_color:
	result_color = object_color × (ambient_color / 255.0) × ambient_ratio


//calculation for object_diffuse_color:
	result_color = object_color × light_color × diffuse_intensity × light_brightness;

	in which, diffuse_intensity = max(0.0, dot(normal, light_dir));
		The dot product describes how "directly" the surface is facing the light source.
		It gives the cosine of the angle between:
			a. surface normal vector
			b. the direction to the light source
		- the closer the value is to 1, the more directly the surface is lit
		- when close to 0, the surface is nearly parallel to the light direction
		- when negative, the surface is back-facing the point light, aka shadowed by itself,
		we take 0.0 for intensity to avoid nagetive lighting.