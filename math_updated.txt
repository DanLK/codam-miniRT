# **************************************************************************** #
#                                                                              #
#                                                          ::::::::            #
#    math.txt                                            :+:    :+:            #
#                                                       +:+                    #
#    By: hogu <hogu@student.codam.nl>                  +#+                     #
#                                                     +#+                      #
#    Created: 2025/08/14 10:15:46 by hogu           #+#    #+#                 #
#    Updated: 2025/08/14 10:15:47 by hogu           ########   odam.nl         #
#                                                                              #
# **************************************************************************** #

//camera ray
Known:
1. horizontal FOV = fov
2. image_height = 600, image_width = 800, viewport_ratio = 4/3
3. camera_position = (a, b, c)
4. camera_direction = (x, y, z)
4. viewport_distance = 1
5. t_vec world_up = (0, 1, 0)

Then:
1. fov_radian = fov * (M_PI / 180.0)
2. viewport_width = tan(fov_radian / 2.0) * viewport_distance * 2.0
3. viewport_height = viewport_width * viewport_ratio
4. viewport_center:
	center.x = a + x * 1.0
	center.y = b + y * 1.0
	center.z = c + z * 1.0
5. local direction on viewport:
	right = normalize(cross(world_up, camera_direction))
	up = normalize(cross(right, camera_direction))
6. upper left point on viewport:
	ulp = center + up * viewport_height / 2 - right * viewport_width / 2
7. pixel size
	pixel_width = viewport_width / image_width
	pixel_height = viewport_height / image_height
8. every point on viewport: (i, j)
	for i (0, 799), j (0, 599)
	t_vec pixel_pos = ulp + right * (i + 0.5) * pixel_width - up * (j + 0.5) * pixel_height
9. ray_vector = normalize(pixel_pos - camera_position)


//hitting cylinder
It is difficult to abstract a cylinder into one single intersection model.
A ray can hit the cylinder in one of three parts:
1. curved side surface
2. top cap (pointed to by axis)
3. bottom cap

For curved surface:
	O = ray.origin
	D = ray.dir
	C = cy.center
	V = cy.dir

1. hit_point = ray.origin + ray.dir * t = O + tD
2. create a vector m from hit_point to cylinder_center
	m = C - (O + tD)
3. get vector n from hit_point to axis, by subtracting m's projection on axis from m
	n = m - dot(m, V) * V

Summing up:
	n = (O - C + tD) - dot(O - C + tD, V) * V

	now let:
	w = O - C
	a = D - dot(D, V) * V
	b = w - dot(w, V) * V

	we get n = b + ta

4. length of n should be radius
	solve: (b + ta) ^ 2 = r ^ 2, the proces is similar to hit_sphere

5. check if hit_point is in between 2 caps
	-h / 2 <= dot(P - C, V) <= h / 2

For each cap:
1. determine a. t_coord cap_center, b. t_vec normal
2. check for parallel ray:
	- similar to hit_plane, get dot product of ray.dir and normal
	- if close to 0, then ray is parallel to cap, no intersection for sure
3. solve for the intersection point (if any)
	- sub_vec(hit_point, cap_center) should be perpendicular to normal
	- hit_point = ray.origin + ray.dir * t
	Details in calculation:
		O = ray.origin
		D = ray.dir
		C = cap_center
		N = normal

		dot(((O + tD) - C), N) = 0			=>
		dot((O - C + tD), N) = 0			=>
		dot(O - C, N) + dot(tD, N) = 0		=>
		dot(O - C, N) + t * dot(D, N) = 0	=>
		t = -dot(O - C, N) / dot(D, N)		=>
		t = dot(C - O, N) / denom
4. check whether hit_point lies inside the cap disk
	distance(hit_plane, cap_center) <= radius

//check_shadow
Checks if a hit_point is in shadow (i.e., blocked from the point light)

logic:
imagine a shadow ray between hit_point and light_point,
and apply hit_object again to all objects one by one, to check if convergence

known:
1. t_coord hit_point
2. t_object *obj
3. t_coord light_point

steps:
1. get the shadow ray from hit_point to light_point
	t_vec shadow_dir = sub_vec(lihgt_point, hit_point);
	t_ray shadow = set_ray(hit_point, shadow_dir);
2. hit_object(shadow, obj, &dist)
3. also check if dist > EPSILON and dist < len_vec of shadow ray
4. if true -> is in_shadow; otherwise -> not in_shadow


//calculate color

logic:
each pixel belongs to one of the three groups:
1. background: gradient
2. object in shadow: object_ambient_color
3. object in light: object_ambient_color + object_diffuse_color


// calculation for object_ambient_color:
	result_color = object_color × (ambient_color / 255.0) × ambient_ratio


//calculation for object_diffuse_color:
	result_color = object_color × light_color × diffuse_intensity × light_brightness;

	in which, diffuse_intensity = max(0.0, dot(normal, light_dir));
		The dot product describes how "directly" the surface is facing the light source.
		It gives the cosine of the angle between:
			a. surface normal vector
			b. the direction to the light source
		- the closer the value is to 1, the more directly the surface is lit
		- when close to 0, the surface is nearly parallel to the light direction
		- when negative, the surface is back-facing the point light, aka shadowed by itself,
		we take 0.0 for intensity to avoid nagetive lighting.


// Finding normal vector for hit_points on cylinder:
1. determine where is the hit_point: 1) bottom flat surface 2) top flat surface 3) curved surface
	(note: axis points towards the top cap)
	project the vector [from cylinder_center to hit_point] onto the cylinder's axis
	in which,
		t_vec v = hit_point - cylinder.center
		proj = dot(v, cylinder.dir)
	now we can determine hit_point position based on projection:
		- if proj = height / 2, the hit_point is on the top cap;
		- if proj = -height / 2 -> bottom cap;
		- if proj is within (-height / 2 , +height / 2), the hit_point is on the curved surface
2. determine the normal vector
	for hit_point on the top cap: same as axis vector
	for bottom cap: opposite to axis vector
	for curved surface: normalized(v - proj * axis)